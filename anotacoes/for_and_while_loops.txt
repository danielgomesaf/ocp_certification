for(;;) é válido, e equivale a while(true). Isso se dá pelo fato de que o for é dividido em três partes, 
que são OPCIONAIS: inicialização do loop, alguma condição de continuidade do loop e ação ao final de 
cada iteração. 

No caso do for(;;), não declaramos nem a inicialização nem a finalização, portanto, nada será feito. 
E como a condição também não foi declarada, assume-se true como default.

--------------------------------------------------------------------------------------------------------

Em um for loop, as seguintes opções podem ser usadas na inicialização e no incremento:

1 - Atribuição:
Ex: 

for (int i = 0; i < 10; i = i + 1) {}

2 - Expressão pós incremento:
Ex: 

int i = 0;

for (i++; i < 10; i++) {}

3 - Expressão pré incremento:
Ex:

int i = 0;

for (++i; i < 10; ++i) {}

4 - Expressão pós decremento:
Ex: 

int i = 10;

for (i--; i > 10; i--) {}

5 - Expressão pré decremento:
Ex:

int i = 10;

for (--i; i > 10; --i) {}

6 - Invocação de método:
Ex:

public class Test {
	static int contador = 0;	

	static int contador() {
		return contador;
	}

	static int acrescentarContador() {
		return contador++;
	}

	public static void main(String[] args) {
		for (contador(); contador() > 10; acrescentarContador()) {}
	}
}

7 - Criação de instância de classe:
Ex:

public class Test {
	public static void main(String[] args) {
		for (new Contador().cont; new Contador().cont < 10; new Contador().cont++) {}		
	}
}

class Contador {
	static int cont = 0;
}

--------------------------------------------------------------------------------------------------------

Dado o cenário:

public class Test {
    public static void main(String[] args) {
        outer: for(var i = 0; i < 3; System.out.print(i)) {
            i++;
            inner: for(var j = 0; j < 3; System.out.print(j)) {
                if(i > ++j) {
                    break outer;
                }
            }
        }
    }
}

Vamos checar as interações:

1st iteração de outer: i = 0. i < 3 avalia como true.

    i = 1.

    // 1st iteração de inner: j = 0. j < 3 avalia como true, já que j = 0. A expressão Booleana 
    // `i > ++j` = `1 > 1` avalia como false. j = 1.

    // 2nd iteração de inner: `System.out.print(j)` printa 1 no console. j < 3 avalia como true já que 
    // j = 1. A expressão Booleana `i > ++j` = `1 > 2` avalia como false. j = 2.

    // 3rd interação de inner: `System.out.print(j)` printa 2 no console. j < 3 avalia como true já que 
    // j = 2. A expressão Booleana `i > ++j` = `1 > 3` avalia em false. j = 3.

    // 4th iteração de inner: `System.out.print(j)` printa 3 to the console. j < 3 avalia como false, já 
    // que j = 3. O controle sai do loop inner, e vai para a expressão de atualização do outer loop

2nd iteração de outer: `System.out.print(i)` printa 1 no console. i < 3 avalia como true já que i = 1.

    i = 2.

    // 1st iteração de inner: j = 0. j < 3 avalia como true, já que j = 0. A expressão Booleana 
    // `i > ++j` = `2 > 1` avalia como true. j = 1. ` break outer;` retorna o controle para fora do loop 
    // outer.

O programa termina com sucesso após printar no console 1231.

--------------------------------------------------------------------------------------------------------

Dado o cenário:

public class Test {
    public static void main(String[] args) {
        int x = 5;
        while (x < 10) 
            System.out.println(x);
            x++;
    }
}

Quando o loop while não tem chaves ao seu redor, apenas a primeira declaração após a identação é 
considerada como parte do loop.

No caso acima, podemos reescrever como:

int x = 5;

while (x < 10) {
	System.out.println(x);
}

x++;

O que faria com que o loop executasse infinitamente.